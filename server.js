const whiteCards = ["Å smekke på deg langbukse", 
                     "Fitte",
                     "Bæsj",
                     "Å ikkje orka mere",
                     "Penis",
                     "Å gå og henge seg",
                     "Milbi",
                     "Å holde på å si",
                     "Databrus",
                     "Dritt og møkk",
                     "Overvekt",
                     "En god fisk, en slags hai",
                     "Oddmund",
                     "Et variert og næringsrikt kosthold",
                     "Medfødt nevromuskulær sykdom",
                     "Erektil dysfunksjon",
                     "Å bli fucked up blast, det er planen min",
                     "Neger",
                     "Åtte eller fler hauger med oppvask",
                     "Sæd",
                     "Å blåse av seg hodet med dobbelløpshagle",
                     "Hud",
                     "Forhuden",
                     "Litt elskov med bikkja",
                     "Taco",
                     "Eufori",
                     "Å rope",
                     "Å tape alt",
                     "En flodhest",
                     "Pølse i lompe, men uten lompe",
                     "Å ta selvmord",
                     "Døden",
                     "Frosk",
                     "En svulst i nakken",
                     "En kjøter",
                     "Å terge niggers",
                     "Å snorte cola av rompa til en deilig shorty",
                     "Promp",
                     "Prompelukt",
                     "Døhlen",
                     "Å suge kukk",
                     "Å ikke suge kukk",
                     "Å selge skinnet før bjørnen er skutt",
                     "Sixpack",
                     "Runking",
                     "Å sulte, å knapt ha mat",
                     "Å ha det grusomt, å ha det helt forferdelig",
                     "Porno",
                     "Thomas Strømstad",
                     "Magen til Thomas Strømstad",
                     "Å brette på seg langbukse",
                     "Å flekke på seg langbukse",
                     "Tissen",
                     "At det er min dag i dag. Herregud for en herlig dag!",
                     "Å ane hvor mye kuk en skal få i rompa",
                     "Å holde på å si",
                     "Å holde på å skli",
                     "Flaks",
                     "Laks",
                     "Å være en galematias",
                     "En kopp kaffekopp",
                     "Ubeskyttet samleie",
                     "Frenulum",
                     "En generaltabbe",
                     "En genial idé",
                     "Brøstmjælk",
                     "Å parkere tøfla",
                     "Å simpelthen gi opp",
                     "Pakkis",
                     "Frokost",
                     "Lunsj",
                     "300 milliarder kroner",
                     "Semi",
                     "Faen",
                     "Faen i helvette",
                     "21 års forvaring",
                     "Rizz",
                     "Jizz",
                     "Å få grisebank",
                     "Et ninja-snikangrep",
                     "Dyskesi",
                     "Å være aller best",
                     "Pikkpikkpikkpikkpikkpikkpikkpikkpikk",
                     "HJEEEEEELP!!! JEG TRENGER HJEEEELP!!",
                     "Haram",
                     "Muhammed",
                     "Anders",
                     "Behring",
                     "Breivik",
                     "At litt svinn må man regne med",
                     "At kake er godt",
                     "En som heter Daniel",
                     "Albino",
                     "Kukkpikk",
                     "Å ta'n i senk verbalt",
                     "Minecraft",
                     "Å være hensynsfull, aktpågivende og varsom",
                     "Å mige",
                     "En fem-minutter",
                     "Oddmund",
                     "En og en halv time",
                     "Sex",
                     "Et dra-til-tryne",
                     "Å få pungen i klem",
                     "Hoggorm",
                     "Å ringe Ave",
                     "Hastemøte på porselenkontoret",
                     "Ti tusen snus",
                     "Å banke kona",
                     "Kona mi, som jeg banket",
                     "Å hete leif",
                     "Mange nye chics på liggelista mi",
                     "Verdens eldste mann",
                     "Hjerte-og-karsykdommer",
                     "Å få hjerteinnfarkt og slag og dø",
                     "Artur Wiltersen",
                     "Hans Olav Lahlum",
                     "Hesten",
                     "Hestepølse",
                     "Katta",
                     "Å blæste en kar midt i blinken, dama er stygg uten sminken",
                     "Gaming",
                     "Å tørre, og å påstå",
                     "Å være jo-jo-jo-jo-jovial",
                     "Kreft",
                     "Å bli flådd levende",
                     "11. September 2001",
                     "Å være så hjerneskada at man sikler",
                     "Downs",
                     "Å være i bevegelse så det ikke oppstår blodpropper i årene",
                     "Å skru av babyen",
                     "Å hinke",
                     "En integrert oppgaveløsning, hvor det tas høyde for vilkårene som en følge av visjonen",
                     "Å ikke drepe masse folk",
                     "Bremsespor",
                     "HIV, snart AIDS",
                     "Himkok",
                     "Tits",
                     "Å bare kjenne litt på'n",
                     "Smegma",
                     "Auschwitz",
                     "Rundkjøringa på Aursmoen",
                     "Å hive innpå et par blingser",
                     "Mye fett, spesielt rundt midjen",
                     "Å brekke beinet",
                     "Å ikke helt slå på stortromma",
                     "At størrelse har ingenting å si, men hvordan man bruker den"


];

  const blackCards = [ { text: "Hva er den lyden?", replies: 1 },
    { text: "Kong Harald elsker ___.", replies: 1 },
    { text: "Penger kan ikke kjøpe meg kjærlighet, men det kan kjøpe meg ___.", replies: 1 },
    { text: "Thomas Strømstad kom for seint til timen på grunn av ___.", replies: 1 },
    { text: "___ , ___ og ___ Børning 4 kommer snart til en kino nær deg", replies : 3},
    { text: "Hvorfor kom politiet for seint til Utøya?", replies: 1},
    { text: "Filmen ___, en historie om ___.", replies: 2},
    { text: "___ og ___, da var fredagskvelden i boks", replies: 2},
    { text: "Sett hen til en ikke ubetydelig ___, styrkes ___ i henhold til ___", replies: 3},
    { text: "Jeg var født for ___, men jeg er dømt til ___", replies: 2},
    { text: "I dagens episode av Godt Drikke og Filosofi har vi i glasset en klassisk ___ cocktail", replies: 1},
    { text: "Midtlivskrisen til Egil førte til ___.", replies: 1},
    { text: "Ingenting er som og komme hjem til kona, unga, ferdiglaget middag og ___.", replies: 1},
    { text: "Det nye lovende partiet på stortinget, ___-partiet, er det eneste partiet som endelig har tatt for seg ___.", replies: 2},
    { text: "De gamle egypterne er kjent for å ha bygget pyramidene. Lite kjent er det at de også holdt på med ___.", replies: 1 },
    { text: "Topp 3 årets russekonsept: 3. plass:___ 2024, 2. plass ___ 2024, og vinneren var ___2024", replies: 3},
    { text: "Kvinner av Norge har stemt på hva de synes er de mest attraktive hobbyene en mann kan ha. Hobbyen med flest stemmer var ___.", replies: 1},
    { text: "Harry Potter og ___-kammeret", replies: 1},
    { text: "I dag skal vi snakke om holdt på å si ___", replies: 1},
    { text: "Bjørnstjerne Bjørnsons første vise: ___ over grønne åser", replies: 1},
    { text: "30% mindre fett! Prøv den nye super-chipsen med smak av ___!", replies: 1},
    { text: "Treningsopplegg: 4 sets med markløft, 3 sets med benkpress og 3 sets med ___.", replies: 1},
    { text: "De gangene jeg går tom for røyk, blir det ___ istedet", replies: 1},
    { text: "Terrorangrepet på utøya i 2011 var det mest beryktede i Norge fram til 5. april 2026. Dette angrepet ville bli kjent som ___ angrepet.", replies: 1},
    { text: "Unnskyld meg mine herrer, jeg har en date med ___.", replies: 1},
    { text: "Jeg er streng på morningsrutinen min. Først dusjer jeg, så spiser jeg frokost, så ___", replies: 1},
    { text: "Tidligere trodde vi det var et isberg som sank Titanic. Ny forskning viser at det egentlig var ___.", replies: 1},
    { text: "Lars Monsen må overleve i villmarken med bare sine ferdigheter og ___ som hjelpemiddel.", replies: 1}
];

let whiteCardDecks = Array(6).fill().map(() => [...whiteCards]);
let blackCardDecks = Array(6).fill().map(() => [...blackCards]);

let roomReplies = [[], [], [], [], [], []];
let playerAmt = [0, 0, 0, 0, 0, 0];
let roomVotes = [0, 0, 0, 0, 0, 0];
let voteCounter = [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]];

let pointsToWin = [20, 20, 20, 20, 20, 20];
let fillWithBots = [false, false, false, false, false, false];

let gameOn = [false, false, false, false, false, false];

const path = require('path');
const http = require('http');
const express = require('express');
const socketio = require('socket.io');
const { userJoin, getCurrentUser, userLeave, getRoomUsers, setReadyStatus, removeBots } = require('./utils/users');

const app = express();
const server = http.createServer(app);
const io = socketio(server);

const botNames = ["Bot_Arne", "Bot_Kjetil", "Bot_Adolf", "Bot_Per", "Bot_Pål", "Bot_Christer", "Bot_Karsten", "Bot_Vidar", "Bot_Knut", "Bot_Erik", "Bot_Petter", "Bot_Martin"]

// Set static folder
app.use(express.static(path.join(__dirname, 'public')));

// Run when a client connects
io.on('connection', socket=> {
    socket.on('joinRoom', ({ username, room}) => {
        const user = userJoin(socket.id, username, room, false, 0, false);
        socket.join(user.room);

        // Welcome current user
        socket.emit('message', 'Velkommen til spillet');

        // Broadcast when a player connects
        socket.broadcast.to(user.room).emit('message', `${user.username} has joined the game`);

        // If only player in room, make the player room leader
        if (getRoomUsers(user.room).length == 1) {
            socket.emit('roomLeader');
        }

        // Send users and room info
        io.to(user.room).emit('roomUsers', {
            room: user.room,
            users: getRoomUsers(user.room)
        });
    });

    
    // Listen for getBots
    socket.on('getBots', () => {
        const shuffledBots = botNames.sort(() => Math.random() - 0.5);
        const bots = shuffledBots.slice(0, 6);
        
        io.emit('sendBots', bots);
    });

    // Listen for readyStatus
    socket.on('readyStatus', ({id, readyStatus}) => {
        const thisUser = setReadyStatus(id, readyStatus);
        let users = getRoomUsers(thisUser.room);    
        
        // Start game if all players are ready
        if (users.every(user => user.readyStatus)){
            playerAmt[getRoomIndex(id)] = users.length;
            gameOn[getRoomIndex(id)] = true;
            // Fill empty player-spots with bots if requested
            if (fillWithBots[getRoomIndex(id)]){
                const shuffledBotNames = botNames.sort(() => Math.random() - 0.5);
                const botAmt = 6 - users.length;
                for (b = 0; b < botAmt; b++){
                    userJoin("bot" + b.toString(), shuffledBotNames.pop(), thisUser.room, true, 0);
                }
            }     

            users = getRoomUsers(thisUser.room);
            const deckIndex = Number(thisUser.room.charAt(thisUser.room.length - 1)) - 1;

            // Reset decks
            whiteCardDecks[deckIndex] = [...whiteCards];
            blackCardDecks[deckIndex] = [...blackCards];
            shuffle(whiteCardDecks[deckIndex]);
            shuffle(blackCardDecks[deckIndex]);

            // Reset variables
            roomReplies[getRoomIndex(id)] = [];
            roomVotes[getRoomIndex(id)] = 0;
            voteCounter[getRoomIndex(id)] = [0, 0, 0, 0, 0, 0];


            // Deal cards
            users.forEach(user => {
                if (!user.id.startsWith('bot')){
                    for (let c = 0; c < 7; c++){
                        io.to(user.id).emit('drawCard', whiteCardDecks[deckIndex].pop());
                    }
                }
            });

            const blackCard = blackCardDecks[getRoomIndex(id)].pop();

            // Start game
            io.to(thisUser.room).emit('startGame', blackCard);
            io.to(thisUser.room).emit('displayPointGoal', pointsToWin[getRoomIndex(id)]);

            // Set all players readyStatus to false
            users.forEach(user => {
                setReadyStatus(user.id, false);
            });

            // Set first reading player
            users[users.length - 1].isReading = true;

            // Set next reading player
            let readerIndex;
            users.forEach((user, index) =>{
                if (user.isReading) {
                    user.isReading = false;
                    readerIndex = index;
                }
            });

            while(!users[readerIndex].isReading) {
                readerIndex ++;
                if (readerIndex > users.length - 1) readerIndex = 0;
                if (!users[readerIndex].id.startsWith('bot')){
                    users[readerIndex].isReading = true;
                }
            }

            // Send users and room info
            io.to(thisUser.room).emit('roomUsers', {
                room: thisUser.room,
                users: getRoomUsers(thisUser.room)
            });

            io.to(users[readerIndex].id).emit('isReading');
        }

        // Send users and room info
        io.to(thisUser.room).emit('roomUsers', {
            room: thisUser.room,
            users: getRoomUsers(thisUser.room)
        });
    });

    // Get game settings from room leader (points to win, fill with bots)
    socket.on('gameSettings', ({ptw, fwb, id}) => {
        if (ptw > 0) pointsToWin[getRoomIndex(id)] = ptw;
        else pointsToWin[getRoomIndex(id)] = 20;
        fillWithBots[getRoomIndex(id)] = fwb;
    });

    socket.on('requestDrawCard', (id) =>{
        const thisUser = getCurrentUser(id);    
        const deckIndex = getRoomIndex(id);
        // If few cards left, refill the deck
        if (whiteCardDecks[deckIndex].length < 30) whiteCardDecks[deckIndex] = [...whiteCards];
        io.to(thisUser.id).emit('drawCard', whiteCardDecks[deckIndex].pop());
    });

    socket.on('submitCards', ({ cards, id, rplyAmt}) => {
        const thisUser = getCurrentUser(id);
        roomReplies[getRoomIndex(id)].push({reply: cards, name: thisUser.username});

        // Check if all players have submitted cards
        if (roomReplies[getRoomIndex(id)].length == playerAmt[getRoomIndex(id)]){

            // If there are bots in the game, make random replies
            users = getRoomUsers(thisUser.room);
            users.forEach(user => {
                if (user.id.startsWith('bot')){
                    let botReply = [];
                    for (let c = 0; c < rplyAmt; c++){
                        botReply.push(whiteCardDecks[getRoomIndex(id)].pop());
                    }
                    roomReplies[getRoomIndex(id)].push({reply: botReply, name: user.username});
                }
            });

            // Shuffle replies so that you can't tell who played what
            shuffle(roomReplies[getRoomIndex(id)]);

            

            io.to(thisUser.room).emit('revealReplies', roomReplies[getRoomIndex(id)]);
        }
    });

    socket.on('requestShowNewCard', (id) => {
        user = getCurrentUser(id);
        io.to(user.room).emit('showNewCard');
    });

    socket.on('voteForPlayer', ({pv, voterId, indx}) => {

        const voter = getCurrentUser(voterId);
        const users = getRoomUsers(voter.room);
        const userGettingPoint = users.find(user => user.username == pv);
        userGettingPoint.points += 1;
        roomVotes[getRoomIndex(voterId)] += 1;

        voteCounter[getRoomIndex(voterId)][indx] += 1;

        // Check if all players have voted
        if (roomVotes[getRoomIndex(voterId)] == playerAmt[getRoomIndex(voterId)]){
            // Check if any player has won
            let victoriousPlayer = "";
            users.forEach(user => {
                if (user.points >= pointsToWin[getRoomIndex(user.id)]){
                    victoriousPlayer = user.username;
                }
            });
            io.emit('revealVotes', { users:getRoomUsers(voter.room), votes: voteCounter[getRoomIndex(voterId)], winningPlayer: victoriousPlayer});

            // Make all bots ready for next turn
            users.forEach(user => {
                if (user.id.startsWith('bot')) user.readyStatus = true;
            });
        }
    });

    socket.on('readyForNextRound', (id) => {
        thisUser = getCurrentUser(id);
        thisUser.readyStatus = true;

        users = getRoomUsers(thisUser.room);

        // Check if all players are ready for next turn
        if (users.every(user => user.readyStatus)) {

            // Unready all players
            users.forEach(user => {
                user.readyStatus = false;
            });

            // Set up for next round
            roomReplies[getRoomIndex(id)] = [];
            roomVotes[getRoomIndex(id)] = 0;
            voteCounter[getRoomIndex(id)] = [0, 0, 0, 0, 0, 0];

            const blackCard = blackCardDecks[getRoomIndex(id)].pop();

            // If few cards left, refill deck
            if (blackCardDecks[getRoomIndex(id)].length < 3) {
                blackCardDecks[getRoomIndex(id)] = [...blackCards];
            }

            // Set next reading player
            let readerIndex;
            users.forEach((user, index) =>{
                if (user.isReading) {
                    user.isReading = false;
                    readerIndex = index;
                }
            });

            while(!users[readerIndex].isReading) {
                readerIndex ++;
                if (readerIndex > users.length - 1) readerIndex = 0;
                if (!users[readerIndex].id.startsWith('bot')){
                    users[readerIndex].isReading = true;
                }
            }

            // Send users and room info
            io.to(thisUser.room).emit('roomUsers', {
                room: thisUser.room,
                users: getRoomUsers(thisUser.room)
            });

            io.to(users[readerIndex].id).emit('isReading');

            io.emit('nextTurn', blackCard);
        }
    });

    socket.on('requestStartNewGame', roomLeaderId => {
        gameOn[getRoomIndex(roomLeaderId)] = false;

        roomReplies[getRoomIndex(roomLeaderId)] = [];
        roomVotes[getRoomIndex(roomLeaderId)] = 0;
        voteCounter[getRoomIndex(roomLeaderId)] = [0, 0, 0, 0, 0, 0];

        const thisUser = getCurrentUser(roomLeaderId);
        let users = getRoomUsers(thisUser.room);
        // Remove all bots
        removeBots(thisUser.room);
        users = getRoomUsers(thisUser.room);

        // Set all players points to 0, readyStatus false and isReading false
        users.forEach(user => {
            user.points = 0;
            user.readyStatus = false;
            user.isReading = false;
        });


        io.emit('startNewGame', {rLId: roomLeaderId, roomUsers: users});
    });

    // Runs when player disconnects
    socket.on('disconnect', () =>{
        const user = userLeave(socket.id);
        

        if (user){
            const thisRoom = user.room;

            // If all players have left, end the game
            if (getRoomUsers(user.room).length == 0){
                gameOn[Number(thisRoom.charAt(thisRoom.length -1)) - 1] = false;
            }

            io.to(user.room).emit('message', `${user.username} has left the game`);

                // Send users and room info
            io.to(user.room).emit('roomUsers', {
                room: user.room,
                users: getRoomUsers(user.room)
            });
        }

        
        
    });
});

function shuffle(deck){
    for(let i = 0; i < deck.length; i++){
        let j = Math.floor(Math.random() * deck.length);
        let temp = deck[i];
        deck[i] = deck[j];
        deck[j] = temp;
    }
}

// Get the index of the room of the player
function getRoomIndex(id){
    const user = getCurrentUser(id);
    return Number(user.room.charAt(user.room.length -1)) - 1;
}

const PORT = process.env.PORT || 10000;

server.listen(PORT, () => console.log(`Server running on port ${PORT}`));