const whiteCards = ["Å smekke på deg langbukse", 
                     "Fitte",
                     "Bæsj",
                     "Å ikkje orka mere",
                     "Penis",
                     "Å gå og henge seg",
                     "Milbi",
                     "Å holde på å si",
                     "Databrus",
                     "Dritt og møkk",
                     "Overvekt",
                     "En god fisk, en slags hai",
                     "Oddmund",
                     "Et variert og næringsrikt kosthold",
                     "Medfødt nevromuskulær sykdom",
                     "Erektil dysfunksjon",
                     "Å bli fucked up blast, det er planen min",
                     "Neger",
                     "Åtte eller fler hauger med oppvask",
                     "Sæd",
                     "Å blåse av seg hodet med dobbelløpshagle",
                     "Hud",
                     "Forhuden",
                     "Litt elskov med bikkja",
                     "Taco",
                     "Eufori",
                     "Å rope",
                     "Å tape alt",
                     "En flodhest",
                     "Pølse i lompe, men uten lompe",
                     "Å ta selvmord",
                     "Døden",
                     "Frosk",
                     "En svulst i nakken",
                     "En kjøter",
                     "Å terge niggers",
                     "Å snorte cola av rompa til en deilig shorty",
                     "Promp",
                     "Prompelukt",
                     "Døhlen",
                     "Å suge kukk",
                     "Å ikke suge kukk",
                     "Å selge skinnet før bjørnen er skutt",
                     "Sixpack",
                     "Runking",
                     "Å sulte, å knapt ha mat",
                     "Å ha det grusomt, å ha det helt forferdelig",
                     "Porno",
                     "Thomas Strømstad",
                     "Magen til Thomas Strømstad",
                     "Å brette på seg langbukse",
                     "Å flekke på seg langbukse",
                     "Tissen",
                     "At det er min dag i dag. Herregud for en herlig dag!",
                     "Å ane hvor mye kuk en skal få i rompa",
                     "Å holde på å si",
                     "Å holde på å skli",
                     "Flaks",
                     "Laks",
                     "Å være en galematias",
                     "En kopp kaffekopp",
                     "Ubeskyttet samleie",
                     "Frenulum",
                     "En generaltabbe",
                     "En genial idé",
                     "Brøstmjælk",
                     "Å parkere tøfla",
                     "Å simpelthen gi opp",
                     "Pakkis",
                     "Frokost",
                     "Lunsj",
                     "300 milliarder kroner",
                     "Semi",
                     "Faen",
                     "Faen i helvette",
                     "21 års forvaring",
                     "Rizz",
                     "Jizz",
                     "Å få grisebank",
                     "Et ninja-snikangrep",
                     "Dyskesi",
                     "Å være aller best",
                     "Pikkpikkpikkpikkpikkpikkpikkpikkpikk",
                     "HJEEEEEELP!!! JEG TRENGER HJEEEELP!!",
                     "Haram",
                     "Muhammed",
                     "Anders",
                     "Behring",
                     "Breivik",
                     "At litt svinn må man regne med",
                     "At kake er godt",
                     "En som heter Daniel",
                     "Albino",
                     "Kukkpikk",
                     "Å ta'n i senk verbalt",
                     "Minecraft",
                     "Å være hensynsfull, aktpågivende og varsom",
                     "Å mige",
                     "En fem-minutter",
                     "Oddmund",
                     "En og en halv time",
                     "Sex",
                     "Et dra-til-tryne",
                     "Å få pungen i klem",
                     "Hoggorm",
                     "Å ringe Ave",
                     "Hastemøte på porselenkontoret",
                     "Ti tusen snus",
                     "Å banke kona",
                     "Kona mi, som jeg banket",
                     "Å hete leif"
];

  const blackCards = [ { text: "Hva er den lyden?", replies: 1 },
    { text: "Kong Harald elsker ___.", replies: 1 },
    { text: "Penger kan ikke kjøpe meg kjærlighet, men det kan kjøpe meg ___.", replies: 1 },
    { text: "Thomas Strømstad kom for seint til timen på grunn av ___.", replies: 1 },
    { text: "___ , ___ og ___ Børning 4 kommer snart til en kino nær deg", replies : 3},
    { text: "Hvorfor kom politiet for seint til Utøya?", replies: 1},
    { text: "Filmen ___, en historie om ___.", replies: 2},
    { text: "___ og ___, da var fredagskvelden i boks", replies: 2},
    { text: "Sett hen til en ikke ubetydelig ___, styrkes ___ i henhold til ___", replies: 3},
    { text: "Jeg var født for ___, men jeg er dømt til ___", replies: 2},
    { text: "I dagens episode av Godt Drikke og Filosofi har vi i glasset en klassisk ___ cocktail", replies: 1},
    { text: "Midtlivskrisen til Egil førte til ___.", replies: 1},
    { text: "Ingenting er som og komme hjem til kona, unga, ferdiglaget middag og ___.", replies: 1},
    { text: "Det nye lovende partiet på stortinget, ___-partiet, er det eneste partiet som endelig har tatt for seg ___.", replies: 2},
    { text: "De gamle egypterne er kjent for å ha bygget pyramidene. Lite kjent er det at de også holdt på med ___.", replies: 1 },
    { text: "Topp 3 årets russekonsept: 3. plass:___ 2024, 2. plass ___ 2024, og vinneren var ___2024", replies: 3},
    { text: "Kvinner av Norge har stemt på hva de synes er de mest attraktive hobbyene en mann kan ha. Hobbyen med flest stemmer var ___", replies: 1},
    { text: "Harry Potter og ___-kammeret", replies: 1},
    { text: "I dag skal vi snakke om holdt på å si ___", replies: 1},

];

let whiteCardDecks = Array(6).fill().map(() => [...whiteCards]);
let blackCardDecks = Array(6).fill().map(() => [...blackCards]);

let roomReplies = [[], [], [], [], [], []];
let playerAmt = [0, 0, 0, 0, 0, 0];
let roomVotes = [0, 0, 0, 0, 0, 0];
let voteCounter = [[0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0]];

let pointsToWin = [20, 20, 20, 20, 20, 20];
let fillWithBots = [false, false, false, false, false, false];

let gameOn = [false, false, false, false, false, false];

const path = require('path');
const http = require('http');
const express = require('express');
const socketio = require('socket.io');
const { userJoin, getCurrentUser, userLeave, getRoomUsers, setReadyStatus, removeBots } = require('./utils/users');

const app = express();
const server = http.createServer(app);
const io = socketio(server);

const botNames = ["Bot_Arne", "Bot_Kjetil", "Bot_Adolf", "Bot_Per", "Bot_Pål", "Bot_Christer", "Bot_Karsten", "Bot_Vidar", "Bot_Knut", "Bot_Erik", "Bot_Petter", "Bot_Martin"]

// Set static folder
app.use(express.static(path.join(__dirname, 'public')));

// Run when a client connects
io.on('connection', socket=> {
    socket.on('joinRoom', ({ username, room}) => {
        const user = userJoin(socket.id, username, room, false, 0, false);
        socket.join(user.room);

        // Welcome current user
        socket.emit('message', 'Velkommen til spillet');

        // Broadcast when a player connects
        socket.broadcast.to(user.room).emit('message', `${user.username} has joined the game`);

        // If only player in room, make the player room leader
        if (getRoomUsers(user.room).length == 1) {
            socket.emit('roomLeader');
        }

        // Send users and room info
        io.to(user.room).emit('roomUsers', {
            room: user.room,
            users: getRoomUsers(user.room)
        });
    });

    
    // Listen for getBots
    socket.on('getBots', () => {
        const shuffledBots = botNames.sort(() => Math.random() - 0.5);
        const bots = shuffledBots.slice(0, 6);
        
        io.emit('sendBots', bots);
    });

    // Listen for readyStatus
    socket.on('readyStatus', ({id, readyStatus}) => {
        const thisUser = setReadyStatus(id, readyStatus);
        let users = getRoomUsers(thisUser.room);    
        
        // Start game if all players are ready
        if (users.every(user => user.readyStatus)){
            playerAmt[getRoomIndex(id)] = users.length;
            gameOn[getRoomIndex(id)] = true;
            // Fill empty player-spots with bots if requested
            if (fillWithBots[getRoomIndex(id)]){
                const shuffledBotNames = botNames.sort(() => Math.random() - 0.5);
                const botAmt = 6 - users.length;
                for (b = 0; b < botAmt; b++){
                    userJoin("bot" + b.toString(), shuffledBotNames.pop(), thisUser.room, true, 0);
                }
            }     

            users = getRoomUsers(thisUser.room);
            const deckIndex = Number(thisUser.room.charAt(thisUser.room.length - 1)) - 1;

            // Reset decks
            whiteCardDecks[deckIndex] = [...whiteCards];
            blackCardDecks[deckIndex] = [...blackCards];
            shuffle(whiteCardDecks[deckIndex]);
            shuffle(blackCardDecks[deckIndex]);

            // Reset variables
            roomReplies[getRoomIndex(id)] = [];
            roomVotes[getRoomIndex(id)] = 0;
            voteCounter[getRoomIndex(id)] = [0, 0, 0, 0, 0, 0];


            // Deal cards
            users.forEach(user => {
                if (!user.id.startsWith('bot')){
                    for (let c = 0; c < 7; c++){
                        io.to(user.id).emit('drawCard', whiteCardDecks[deckIndex].pop());
                    }
                }
            });

            const blackCard = blackCardDecks[getRoomIndex(id)].pop();

            // Start game
            io.to(thisUser.room).emit('startGame', blackCard);
            io.to(thisUser.room).emit('displayPointGoal', pointsToWin[getRoomIndex(id)]);

            // Set all players readyStatus to false
            users.forEach(user => {
                setReadyStatus(user.id, false);
            });

            // Set first reading player
            users[0].isReading = true;
        }

        // Send users and room info
        io.to(thisUser.room).emit('roomUsers', {
            room: thisUser.room,
            users: getRoomUsers(thisUser.room)
        });
    });

    // Get game settings from room leader (points to win, fill with bots)
    socket.on('gameSettings', ({ptw, fwb, id}) => {
        if (ptw > 0) pointsToWin[getRoomIndex(id)] = ptw;
        else pointsToWin[getRoomIndex(id)] = 20;
        fillWithBots[getRoomIndex(id)] = fwb;
    });

    socket.on('requestDrawCard', (id) =>{
        const thisUser = getCurrentUser(id);
        const deckIndex = getRoomIndex(id);
        io.to(thisUser.id).emit('drawCard', whiteCardDecks[deckIndex].pop());
    });

    socket.on('submitCards', ({ cards, id, rplyAmt}) => {
        const thisUser = getCurrentUser(id);
        roomReplies[getRoomIndex(id)].push({reply: cards, name: thisUser.username});

        // Check if all players have submitted cards
        if (roomReplies[getRoomIndex(id)].length == playerAmt[getRoomIndex(id)]){

            // If there are bots in the game, make random replies
            users = getRoomUsers(thisUser.room);
            users.forEach(user => {
                if (user.id.startsWith('bot')){
                    let botReply = [];
                    for (let c = 0; c < rplyAmt; c++){
                        botReply.push(whiteCardDecks[getRoomIndex(id)].pop());
                    }
                    roomReplies[getRoomIndex(id)].push({reply: botReply, name: user.username});
                }
            });

            // Shuffle replies so that you can't tell who played what
            shuffle(roomReplies[getRoomIndex(id)]);

            // Set next reading player
            let readerIndex;
            users.forEach((user, index) =>{
                if (user.isReading) {
                    user.isReading = false;
                    readerIndex = index;
                }
            });

            while(!users[readerIndex].isReading) {
                readerIndex ++;
                if (readerIndex > users.length - 1) readerIndex = 0;
                if (!users[readerIndex].id.startsWith('bot')){
                    users[readerIndex].isReading = true;
                }
            }

            // Send users and room info
            io.to(thisUser.room).emit('roomUsers', {
                room: thisUser.room,
                users: getRoomUsers(thisUser.room)
            });

            io.to(users[readerIndex].id).emit('isReading');

            io.to(thisUser.room).emit('revealReplies', roomReplies[getRoomIndex(id)]);
        }
    });

    socket.on('requestShowNewCard', (id) => {
        user = getCurrentUser(id);
        io.to(user.room).emit('showNewCard');
    });

    socket.on('voteForPlayer', ({pv, voterId, indx}) => {

        const voter = getCurrentUser(voterId);
        const users = getRoomUsers(voter.room);
        const userGettingPoint = users.find(user => user.username == pv);
        userGettingPoint.points += 1;
        roomVotes[getRoomIndex(voterId)] += 1;

        voteCounter[getRoomIndex(voterId)][indx] += 1;

        // Check if all players have voted
        if (roomVotes[getRoomIndex(voterId)] == playerAmt[getRoomIndex(voterId)]){
            // Check if any player has won
            let victoriousPlayer = "";
            users.forEach(user => {
                if (user.points >= pointsToWin[getRoomIndex(user.id)]){
                    victoriousPlayer = user.username;
                }
            });
            io.emit('revealVotes', { users:getRoomUsers(voter.room), votes: voteCounter[getRoomIndex(voterId)], winningPlayer: victoriousPlayer});

            // Make all bots ready for next turn
            users.forEach(user => {
                if (user.id.startsWith('bot')) user.readyStatus = true;
            });
        }
    });

    socket.on('readyForNextRound', (id) => {
        thisUser = getCurrentUser(id);
        thisUser.readyStatus = true;

        users = getRoomUsers(thisUser.room);

        // Check if all players are ready for next turn
        if (users.every(user => user.readyStatus)) {

            // Unready all players
            users.forEach(user => {
                user.readyStatus = false;
            });

            // Set up for next round
            roomReplies[getRoomIndex(id)] = [];
            roomVotes[getRoomIndex(id)] = 0;
            voteCounter[getRoomIndex(id)] = [0, 0, 0, 0, 0, 0];

            const blackCard = blackCardDecks[getRoomIndex(id)].pop();

            io.emit('nextTurn', blackCard);
        }
    });

    socket.on('requestStartNewGame', roomLeaderId => {
        gameOn[getRoomIndex(roomLeaderId)] = false;

        roomReplies[getRoomIndex(roomLeaderId)] = [];
        roomVotes[getRoomIndex(roomLeaderId)] = 0;
        voteCounter[getRoomIndex(roomLeaderId)] = [0, 0, 0, 0, 0, 0];

        const thisUser = getCurrentUser(roomLeaderId);
        let users = getRoomUsers(thisUser.room);
        // Remove all bots
        removeBots(thisUser.room);
        users = getRoomUsers(thisUser.room);

        // Set all players points to 0, readyStatus false and isReading false
        users.forEach(user => {
            user.points = 0;
            user.readyStatus = false;
            user.isReading = false;
        });


        io.emit('startNewGame', {rLId: roomLeaderId, roomUsers: users});
    });

    // Runs when player disconnects
    socket.on('disconnect', () =>{
        const user = userLeave(socket.id);
        

        if (user){
            const thisRoom = user.room;

            // If all players have left, end the game
            if (getRoomUsers(user.room).length == 0){
                gameOn[Number(thisRoom.charAt(thisRoom.length -1)) - 1] = false;
            }

            io.to(user.room).emit('message', `${user.username} has left the game`);

                // Send users and room info
            io.to(user.room).emit('roomUsers', {
                room: user.room,
                users: getRoomUsers(user.room)
            });
        }

        
        
    });
});

function shuffle(deck){
    for(let i = 0; i < deck.length; i++){
        let j = Math.floor(Math.random() * deck.length);
        let temp = deck[i];
        deck[i] = deck[j];
        deck[j] = temp;
    }
}

// Get the index of the room of the player
function getRoomIndex(id){
    const user = getCurrentUser(id);
    return Number(user.room.charAt(user.room.length -1)) - 1;
}

const PORT = process.env.PORT || 3000;

server.listen(PORT, () => console.log(`Server running on port ${PORT}`));